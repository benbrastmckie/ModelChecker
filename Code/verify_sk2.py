#!/usr/bin/env python3
"""
Verify that SK2 generates different formulas than MS.
"""

import sys
sys.path.insert(0, 'src')

import z3
from model_checker.syntactic import Syntax, Sentence
from model_checker.theory_lib.exclusion.semantic import ExclusionSemantics
from model_checker.theory_lib.exclusion.operators import (
    ExclusionOperatorMultiSort,
    ExclusionOperatorSkolemized2,
    create_operator_collection
)

def compare_formulas():
    """Compare the formulas generated by MS and SK2 strategies."""
    print("="*70)
    print("COMPARING MS AND SK2 FORMULA GENERATION")
    print("="*70)
    
    # Settings
    settings = {'N': 3}
    semantics = ExclusionSemantics(settings)
    
    # Create a simple exclusion sentence
    eval_point = {"world": z3.BitVecVal(0, 3)}
    
    # Test argument (just 'A')
    # Create a simple sentence using Syntax
    syntax = Syntax(['A'], [], create_operator_collection('MS'))
    arg_sent = syntax.sentence_letters[0]
    
    # State to verify
    state = z3.BitVec("test_state", 3)
    
    print("\n1. Testing MS (Multi-Sort) Strategy:")
    print("-" * 40)
    ms_op = ExclusionOperatorMultiSort(semantics)
    
    ms_formula = ms_op.extended_verify(state, arg_sent, eval_point)
    ms_str = str(ms_formula)
    
    print(f"Formula length: {len(ms_str)} characters")
    print(f"Contains 'Exists': {'Exists' in ms_str}")
    print(f"Number of 'Exists': {ms_str.count('Exists')}")
    print(f"Contains 'h_ms_': {'h_ms_' in ms_str}")
    
    print("\n2. Testing SK2 (True Skolemization) Strategy:")
    print("-" * 40)
    sk2_op = ExclusionOperatorSkolemized2(semantics)
    
    sk2_formula = sk2_op.extended_verify(state, arg_sent, eval_point)
    sk2_str = str(sk2_formula)
    
    print(f"Formula length: {len(sk2_str)} characters")
    print(f"Contains 'Exists': {'Exists' in sk2_str}")
    print(f"Number of 'Exists': {sk2_str.count('Exists')}")
    print(f"Contains 'h_sk2_': {'h_sk2_' in sk2_str}")
    print(f"Contains 'y_sk2_': {'y_sk2_' in sk2_str}")
    
    print("\n3. Key Differences:")
    print("-" * 40)
    print(f"MS uses existential quantifiers: {'Exists' in ms_str}")
    print(f"SK2 uses existential quantifiers: {'Exists' in sk2_str}")
    print(f"SK2 has Skolem functions for both h and y: {'y_sk2_' in sk2_str}")
    
    # Test nested exclusion
    print("\n4. Testing Nested Exclusion (\\exclude \\exclude A):")
    print("-" * 40)
    
    # Create nested exclusion using syntax
    nested_syntax = Syntax(['\\exclude A'], [], create_operator_collection('MS'))
    inner_excl = nested_syntax.premises[0]
    
    # MS nested
    ms_nested = ms_op.extended_verify(state, inner_excl, eval_point)
    ms_nested_str = str(ms_nested)
    print(f"MS nested 'Exists' count: {ms_nested_str.count('Exists')}")
    
    # SK2 nested
    sk2_nested = sk2_op.extended_verify(state, inner_excl, eval_point)
    sk2_nested_str = str(sk2_nested)
    print(f"SK2 nested 'Exists' count: {sk2_nested_str.count('Exists')}")
    
    print("\n5. Analysis:")
    print("-" * 40)
    print("SK2 should eliminate the existential quantifiers that cause")
    print("the false premise issue. The formulas should contain only")
    print("ForAll quantifiers with explicit Skolem functions.")
    
    # Check if SK2 truly eliminated existentials
    if sk2_str.count('Exists') == 0:
        print("\n✓ SUCCESS: SK2 has NO existential quantifiers!")
        print("This should solve the false premise issue.")
    else:
        print("\n✗ ISSUE: SK2 still has existential quantifiers.")
        print("The implementation may need adjustment.")

if __name__ == "__main__":
    compare_formulas()